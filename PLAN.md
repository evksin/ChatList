# План реализации программы ChatList

## Этап 1: Подготовка проекта и структуры

- [ ] Создать структуру проекта (папки для модулей, если нужно)
- [ ] Настроить requirements.txt с необходимыми зависимостями:
  - PyQt5 (GUI)
  - requests или httpx (HTTP-запросы)
  - python-dotenv (для работы с .env файлом)
  - sqlite3 (встроен в Python)
- [ ] Создать файл .env.example с примером структуры для API-ключей
- [ ] Создать .gitignore для исключения .env и других служебных файлов

## Этап 2: База данных (db.py)

- [ ] Создать модуль db.py с функциями для работы с SQLite
- [ ] Реализовать инициализацию базы данных (создание таблиц):
  - prompts (id, date, prompt, tags)
  - models (id, name, api_url, api_id, is_active)
  - results (id, prompt_id, model_id, response, date, selected)
  - settings (key, value)
- [ ] Реализовать CRUD операции для каждой таблицы:
  - prompts: create, read, update, delete, search, sort
  - models: create, read, update, delete, get_active_models
  - results: create, read, update, delete, search, sort
  - settings: get, set
- [ ] Добавить функции для поиска и сортировки во всех таблицах

## Этап 3: Работа с API (network.py)

- [ ] Создать модуль network.py для отправки HTTP-запросов
- [ ] Реализовать базовый класс или функции для работы с API разных провайдеров:
  - OpenAI API
  - DeepSeek API
  - Groq API
  - (возможность расширения для других провайдеров)
- [ ] Реализовать обработку ошибок и таймаутов
- [ ] Добавить логирование запросов и ответов
- [ ] Реализовать асинхронную отправку запросов (опционально, для ускорения)

## Этап 4: Логика работы с моделями (models.py)

- [ ] Создать модуль models.py
- [ ] Реализовать функции для:
  - Получения списка активных моделей из БД
  - Загрузки API-ключей из .env файла
  - Формирования запросов к разным типам API
  - Парсинга ответов от разных провайдеров
- [ ] Реализовать функцию отправки промта во все активные модели

## Этап 5: Графический интерфейс (main.py)

- [ ] Создать основной класс MainWindow на PyQt5
- [ ] Реализовать интерфейс ввода промта:
  - Поле ввода нового промта
  - Выпадающий список/таблица для выбора сохранённых промтов
  - Кнопка отправки запроса
- [ ] Реализовать интерфейс выбора моделей:
  - Список доступных моделей с чекбоксами для активации/деактивации
- [ ] Реализовать таблицу результатов:
  - Колонки: название модели, текст ответа, чекбокс selected
  - Возможность прокрутки для длинных ответов
- [ ] Реализовать кнопку "Сохранить" для сохранения выбранных результатов
- [ ] Добавить меню и панели инструментов:
  - Управление моделями (добавление, редактирование)
  - Управление промтами (просмотр, редактирование, удаление)
  - Просмотр сохранённых результатов
  - Настройки программы
  - Экспорт результатов

## Этап 6: Интеграция компонентов

- [ ] Подключить db.py к main.py
- [ ] Интегрировать network.py и models.py для отправки запросов
- [ ] Реализовать логику работы с временной таблицей результатов (в памяти)
- [ ] Реализовать сохранение выбранных результатов в БД
- [ ] Добавить обработку ошибок на уровне GUI
- [ ] Реализовать индикаторы загрузки во время отправки запросов

## Этап 7: Дополнительные функции

- [ ] Реализовать поиск и сортировку во всех таблицах интерфейса
- [ ] Добавить экспорт результатов в Markdown
- [ ] Добавить экспорт результатов в JSON
- [ ] Реализовать логирование запросов в файл
- [ ] Добавить настройки программы (сохранение в таблицу settings)
- [ ] Реализовать управление тегами для промтов

## Этап 8: Тестирование и оптимизация

- [ ] Протестировать работу с разными API провайдерами
- [ ] Проверить обработку ошибок (недоступность API, неверные ключи и т.д.)
- [ ] Оптимизировать производительность при работе с большим количеством моделей
- [ ] Проверить работу с большими объёмами данных в БД
- [ ] Исправить найденные баги

## Этап 9: Документация и финализация

- [ ] Создать README.md с инструкциями по установке и использованию
- [ ] Добавить комментарии в код
- [ ] Создать примеры конфигурации .env файла
- [ ] Подготовить проект к сборке исполняемого файла (PyInstaller)
